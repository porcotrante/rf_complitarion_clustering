//! Main executable for the Random Forest compiler benchmarking suite.
//!
//! This program orchestrates the process of:
//! 1. Loading Random Forest models trained with different seeds.
//! 2. Loading corresponding prediction files generated by the original RFs.
//! 3. Running the RF-to-DT compilation (`transform_rf_partitioned`) for various
//!    partitioning depths (`k`) and early stopping strategies.
//! 4. Measuring performance (wall time, CPU time, component timings) for the compilation.
//! 5. Verifying the compiled tree's predictions against the original RF's predictions.
//! 6. Storing benchmark results (performance metrics, node counts, height, mismatches)
//!    incrementally to a CSV file.
//! 7. Printing a summary table of results to the console.
//! 8. Optionally calling a Python script to visualize the results from the generated CSV.

// --- Memory Allocator ---
// Use mimalloc for potential performance improvements, especially in multi-threaded scenarios (like parallel partitioning).
use mimalloc::MiMalloc;
use results::BenchmarkResult;
#[global_allocator]
static GLOBAL: MiMalloc = MiMalloc;


// --- Internal Modules ---
mod tree;           // Core tree data structures (Arena, NodeId).
mod utils;          // Utility functions (stats calculation).
mod transform;      // Core transformation logic (RF -> DT).
mod export;         // Tree export/visualization utilities (e.g., height calculation).
mod cpu_time;       // Platform-specific CPU time measurement.
mod config;         // Constants and settings.
mod results;        // CSV export and result handling.
mod benchmark;      // Benchmarking logic (timing, verification).
mod external;       // External calls (e.g., Python visualization script).
mod paths;          //Tree path calculation and comparison of trees.

use crate::benchmark::{TreeComparison, compare_trees};
use crate::transform::{load_rf_data, RandomForestData};
use crate::utils::calculate_stats;
use std::{path::PathBuf, time::{Instant, Duration}, error::Error};
use config::*; // Access to constants (e.g., CHOSEN_DATASET, NUM_CLASSES)

// ==================================================
// Main Function
// ==================================================

/// Entry point of the application.
/// Parses configuration, iterates through seeds, runs benchmarks, saves results, and triggers visualization.
fn main() -> Result<(), Box<dyn Error>> {
    println!("==================================================");
    println!("=      Random Forest Compiler Benchmarking       =");
    println!("==================================================");

    // --- Print Configuration ---
    println!("[CONFIG] Dataset: {}", DATASET_NAME);
    println!("[CONFIG] k Values: {:?}", K_VALUES);
    println!("[CONFIG] Strategies: {:?}", STRATEGIES_TO_TEST);
    println!("[CONFIG] Benchmark Runs per (seed, k, strategy): {}", NUM_BENCHMARK_RUNS);
    println!("[CONFIG] Seeds: {} to {}", BASE_SEED, BASE_SEED + NUM_SEEDS_TO_RUN - 1);

    // --- Setup Paths and Results Directory ---
    let base_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("src").join("rf");
    let results_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("results"); // Define results_dir here
    std::fs::create_dir_all(&results_dir)?; // Ensure results directory exists
    let csv_filename = results_dir.join(format!("benchmark_results_{}_all_seeds.csv", DATASET_NAME));
    let egap_csv_filename = results_dir.join(format!("egap_benchmark_results_{}_all_seeds.csv", DATASET_NAME));

    // --- Initialize CSV File (Write Header if Needed) ---
    if !csv_filename.exists() {
        println!("[SETUP] Creating CSV file and writing header: {:?}", csv_filename);
        results::write_csv_header(&csv_filename)?;
    } else {
        println!("[SETUP] Appending to existing CSV file: {:?}", csv_filename);
    }

    if !egap_csv_filename.exists() {
        println!("[SETUP] Creating Egap CSV file and writing header: {:?}", egap_csv_filename);
        results::write_csv_header(&egap_csv_filename)?;
    } else {
        println!("[SETUP] Appending to existing Egap CSV file: {:?}", egap_csv_filename);
    }

    // Collect all results for final summary/viz
    let mut all_seed_results: Vec<BenchmarkResult> = Vec::new();
    let mut first_rf_data: Option<RandomForestData> = None;
    let mut distances_to_original: Vec<TreeComparison> =
    Vec::with_capacity(NUM_SEEDS_TO_RUN as usize);

    // --- Loop Over Seeds ---
    for i in 0..NUM_SEEDS_TO_RUN {
        let current_seed = BASE_SEED + i;
        println!("\n===== Processing Seed: {} ({}/{}) =====", current_seed, i + 1, NUM_SEEDS_TO_RUN);

        // Construct file paths for the current seed
        let rf_file_name = format!("rf-{}-seed{}.json", DATASET_NAME, current_seed);
        let pred_file_name = format!("pred-{}-seed{}.csv", DATASET_NAME, current_seed);
        let rf_path_buf = base_path.join(&rf_file_name);
        let prediction_path_buf = base_path.join(&pred_file_name);

        //constructing the file paths for the egap forests
        let egap_rf_file_name = format!("egap-rf-{}-seed{}.json", DATASET_NAME, current_seed);
        let egap_pred_file_name = format!("egap-pred-{}-seed{}.csv", DATASET_NAME, current_seed);
        let egap_rf_path_buf = base_path.join(&egap_rf_file_name);
        let egap_prediction_path_buf = base_path.join(&egap_pred_file_name);

        // Check if input files exist, skip seed if not
        if !rf_path_buf.exists() {
            eprintln!("[ERROR] RF file not found for seed {}: {:?}. Skipping seed.", current_seed, rf_path_buf);
            continue;
        }
        if !prediction_path_buf.exists() {
            eprintln!("[ERROR] Prediction file not found for seed {}: {:?}. Skipping seed.", current_seed, prediction_path_buf);
            continue;
        }

        if !egap_rf_path_buf.exists() {
            eprintln!("[ERROR] RF file not found for seed {}: {:?}. Skipping seed.", current_seed, egap_rf_path_buf);
            continue;
        }
        if !egap_prediction_path_buf.exists() {
            eprintln!("[ERROR] Prediction file not found for seed {}: {:?}. Skipping seed.", current_seed, egap_prediction_path_buf);
            continue;
        }

        // --- 1. Load RF Data ---
        // Optionally benchmark loading time only for the first seed
        let rf_data = if i == 0 {
            println!("\n[BENCH] Running Load & Simplify x {} (load/simplify time reported for the first seed only)...", NUM_BENCHMARK_RUNS);
            let mut load_durations: Vec<Duration> = Vec::with_capacity(NUM_BENCHMARK_RUNS);
            for _ in 0..NUM_BENCHMARK_RUNS {
                let load_start = Instant::now();
                let data = load_rf_data(&rf_path_buf)?;
                load_durations.push(load_start.elapsed());
                if first_rf_data.is_none() {
                    first_rf_data = Some(data);
                }
            }
            let (load_min, load_median, load_max, load_mean, load_std_dev) = calculate_stats(&load_durations);
            println!("[RESULT] Load & Simplify (Seed {}): min={:.3}s med={:.3}s max={:.3}s mean={:.3}s std={:.3}s",
                     current_seed, load_min, load_median, load_max, load_mean, load_std_dev);
            first_rf_data.clone().ok_or("Failed to load RF data for the first seed")?
        } else {
            // Load without timing
            load_rf_data(&rf_path_buf)?
        };

        let egap_rf_data = if i == 0 {
            println!("\n[BENCH] EGAP RF Load & Simplify x {}...", NUM_BENCHMARK_RUNS);
            let mut durations = Vec::with_capacity(NUM_BENCHMARK_RUNS);
            let mut first_egap_rf_data = None;

            for _ in 0..NUM_BENCHMARK_RUNS {
                let start = Instant::now();
                let data = load_rf_data(&egap_rf_path_buf)?;
                durations.push(start.elapsed());
                if first_egap_rf_data.is_none() {
                    first_egap_rf_data = Some(data);
                }
            }

            let stats = calculate_stats(&durations);
            println!(
                "[RESULT] EGAP RF (Seed {}): min={:.3}s med={:.3}s max={:.3}s mean={:.3}s std={:.3}s",
                current_seed, stats.0, stats.1, stats.2, stats.3, stats.4
            );

            first_egap_rf_data.unwrap()
        } else {
            load_rf_data(&egap_rf_path_buf)?
        };

        // --- 2. Run Benchmarks for Current Seed ---
        let mut current_seed_run_results = benchmark::run_benchmarks(&rf_data, &prediction_path_buf, current_seed)?;

        let mut egap_current_seed_run_results: Vec<BenchmarkResult> = benchmark::run_benchmarks(&egap_rf_data, &egap_prediction_path_buf, current_seed)?;

        distances_to_original.push(compare_trees(&rf_data, &egap_rf_data, current_seed));

        // Add seed number to each result struct
        for result in current_seed_run_results.iter_mut() {
            result.seed = current_seed;
        }

        for result in egap_current_seed_run_results.iter_mut() {
            result.seed = current_seed;
        }

        // --- 3. Append Results to CSV ---
        println!("[EXPORT] Appending results for seed {} to CSV...", current_seed);
        results::append_results_to_csv(&current_seed_run_results, &csv_filename)?;
        println!("[EXPORT] Results for seed {} appended.", current_seed);

        println!("[EXPORT] Appending egap results for seed {} to CSV...", current_seed);
        results::append_results_to_csv(&egap_current_seed_run_results, &egap_csv_filename)?;
        println!("[EXPORT] Egap Results for seed {} appended.", current_seed);

        // Store results in memory for final summary table and visualization input
        println!("Inserindo resultados da árvore padrão");
        all_seed_results.extend(current_seed_run_results);
        print!("Inserindo resultados da árvore clusterizada");
        all_seed_results.extend(egap_current_seed_run_results);

    } // End of seed loop

    // --- Check if any results were generated ---
    if all_seed_results.is_empty() {
        eprintln!("[ERROR] No benchmark results collected. Did input files exist for any seed?");
        return Ok(()); // Exit gracefully if no results
    }

    // --- 4. Print Final Summary Table ---
    results::print_summary_table(&all_seed_results);
    results::print_tree_distance_table(&distances_to_original);

    // --- 5. Run Visualization Script ---
    // Pass the path to the CSV file that was incrementally built.
    external::run_visualization(&csv_filename, DATASET_NAME, &results_dir)?;
    external::run_visualization(&egap_csv_filename, DATASET_NAME, &results_dir)?;
    external::run_comparison(&csv_filename, &egap_csv_filename, DATASET_NAME, &results_dir)?;

    println!("\n===== Benchmark Run Complete =====");
    Ok(())
}
